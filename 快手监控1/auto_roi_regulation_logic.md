# 自动ROI调控逻辑文档

## 1. 系统架构

### 1.1 核心组件

| 组件 | 职责 |
|------|------|
| `AutoRoiService` | 自动ROI调控的核心服务类 |
| `roiSvc` | ROI更新服务，负责与外部API交互 |
| `usersSvc` | 用户服务，提供用户信息查询 |
| `send` | 消息发送函数，用于向前端推送更新 |

### 1.2 核心配置

| 配置项 | 值 | 说明 |
|--------|-----|------|
| `MIN_ROI` | 2.66 | 兜底ROI值，所有计算结果不会低于此值 |
| `CONFIG_FILE` | `auto_roi_config.json` | 配置文件路径 |
| `LOG_FILE` | `auto_roi_logs.json` | 日志文件路径 |

## 2. 调控逻辑流程

### 2.1 入口方法

```javascript
async checkAndAdjust(ksData, roiData) {
  // 1. 检查是否启用
  // 2. 数据预处理
  // 3. 遍历每个用户
  // 4. 执行调控逻辑
  // 5. 记录日志
}
```

### 2.2 执行流程

1. **检查启用状态**：如果未启用，直接返回
2. **数据预处理**：
   - 构建ROI数据映射表，提高查询效率
   - 过滤无效数据（消耗为"--"、undefined、null）
3. **遍历处理每个用户**：
   - 计算消耗值
   - 检查ROI是否为0（智能投放跳过）
   - 更新连续0消耗计数
   - 执行调控逻辑
4. **执行更新**：如果需要调整ROI，调用外部API更新
5. **记录日志**：保存调控记录并推送到前端

## 3. 核心调控逻辑

### 3.1 优先级规则

1. **最高优先级**：连续0消耗特殊逻辑（连续次数 ≥ 2）
2. **次优先级**：常规消耗调控逻辑（连续次数 < 2）

### 3.2 连续0消耗逻辑

| 连续0消耗次数 | ROI调整值 | 说明 |
|---------------|-----------|------|
| 2 | -5 | 连续2次0消耗，降低5个点 |
| 3 | -10 | 连续3次0消耗，降低10个点 |
| 4 | -20 | 连续4次0消耗，降低20个点 |
| 5 | -30 | 连续5次0消耗，降低30个点 |
| ≥6 | -40 | 连续6次及以上0消耗，降低40个点 |

### 3.3 常规消耗调控逻辑

| 消耗范围（元） | ROI调整值 | 说明 |
|----------------|-----------|------|
| [0, 0.2] | 0→15: -2<br>15+: -4 | 低消耗，适当降低ROI |
| (0.2, 0.3) | 0→15: -1<br>15+: -4 | 略高于0的消耗，小幅降低ROI |
| [0.3, 0.5] | 0 | 正常消耗范围，保持不变 |
| (0.5, 0.9] | +1 | 消耗增加，小幅提高ROI |
| (0.9, 1.3] | +2 | 消耗进一步增加，提高2个点 |
| (1.3, 1.7] | +3 | 消耗持续增加，提高3个点 |
| (1.7, 2.2] | +4 | 消耗显著增加，提高4个点 |
| (2.2, 3] | +8 | 消耗大幅增加，提高8个点 |
| (3, 5] | +15 | 消耗很高，提高15个点 |
| (5, 13] | +20 | 消耗非常高，提高20个点 |
| >13 | +40 | 消耗极高，大幅提高40个点 |

### 3.4 边界处理

1. **下限检查**：所有计算结果不会低于 `MIN_ROI`（2.66）
2. **上限检查**：所有计算结果不会高于 100
3. **精度处理**：结果保留3位小数

## 4. 数据过滤与特殊处理

### 4.1 过滤规则

1. **无效消耗过滤**：消耗为"--"、undefined、null时跳过
2. **非数字消耗过滤**：无法转换为数字的消耗值跳过
3. **智能投放过滤**：当前ROI为0时跳过（智能投放）
4. **无效ROI过滤**：无法转换为数字的ROI值跳过

### 4.2 特殊处理

- **连续0消耗计数**：
  - 每次消耗为0时，计数加1
  - 消耗不为0时，计数重置为0
  - 计数存储在 `zeroCostCounter` Map中

## 5. 日志记录

### 5.1 日志结构

```javascript
{
  "id": 1234567890,
  "time": "2025-12-14 15:30:00",
  "count": 3,
  "details": [
    {
      "name": "用户名称",
      "cost": 0,
      "oldRoi": 10.0,
      "newRoi": 5.0,
      "status": "success",
      "message": "连续2次0消耗"
    }
  ]
}
```

### 5.2 日志特性

1. **实时推送**：调控记录实时推送到前端
2. **日志限制**：仅保留最近10条日志记录
3. **详细信息**：包含用户名称、消耗值、旧ROI、新ROI、状态和备注

## 6. 状态管理

### 6.1 启用状态

- 默认状态：关闭
- 状态切换：通过 `toggle(enabled)` 方法控制
- 状态持久化：保存到配置文件中

### 6.2 计数管理

- 连续0消耗计数存储在内存中
- 每次应用启动时重置

## 7. 执行机制

### 7.1 触发方式

由 `CountdownService` 定时触发，执行周期由外部配置决定。

### 7.2 执行流程

```
┌─────────────────────────────────────────────────┐
│                   开始调控                      │
└───────────────────────┬─────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────┐
│              检查是否启用                        │
└───────────────────────┬─────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────┐
│              数据预处理                          │
└───────────────────────┬─────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────┐
│              遍历每个用户                        │
└───────────────────────┬─────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────┐
│              检查数据有效性                      │
└───────────────────────┬─────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────┐
│              检查是否为智能投放                  │
└───────────────────────┬─────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────┐
│              更新连续0消耗计数                   │
└───────────────────────┬─────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────┐
│              执行调控逻辑                        │
│  ┌───────────────────────────────────────────┐  │
│  │    连续0消耗逻辑（优先级最高）            │  │
│  └───────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────┐  │
│  │    常规消耗逻辑                            │  │
│  └───────────────────────────────────────────┘  │
└───────────────────────┬─────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────┐
│              边界检查与精度处理                  │
└───────────────────────┬─────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────┐
│              执行ROI更新                        │
└───────────────────────┬─────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────┐
│              记录日志并推送更新                  │
└─────────────────────────────────────────────────┘
```

## 8. 性能优化

### 8.1 数据结构优化

- 使用 `Map` 存储ROI数据，提高查询效率
- 使用 `Map` 存储连续0消耗计数，快速查找和更新

### 8.2 批量处理

- 批量记录日志，减少I/O操作
- 实时推送日志更新，提高用户体验

## 9. 故障处理

### 9.1 异常捕获

- 所有外部API调用都包含异常捕获
- 失败的更新操作会记录详细错误信息
- 单个用户更新失败不会影响其他用户

### 9.2 日志记录

- 成功和失败的操作都会记录到日志
- 日志包含详细的上下文信息，便于排查问题

## 10. 扩展建议

1. **动态配置支持**：允许通过前端界面调整 `MIN_ROI` 等核心参数
2. **自定义调控策略**：支持不同用户组使用不同的调控策略
3. **历史数据分析**：添加历史数据存储和分析功能
4. **机器学习优化**：基于历史数据训练模型，优化调控算法
5. **预警机制**：添加异常消耗和ROI波动的预警功能

## 11. 代码示例

### 11.1 核心调控逻辑调用

```javascript
// 初始化服务
const autoRoiService = new AutoRoiService({
  roiSvc: roiService,
  usersSvc: userService,
  send: (channel, data) => mainWindow.webContents.send(channel, data)
});

// 启用自动调控
autoRoiService.toggle(true);

// 触发调控逻辑（通常由CountdownService定时调用）
autoRoiService.checkAndAdjust(ksData, roiData);
```

### 11.2 调控结果日志

```javascript
{
  "id": 1744600392000,
  "time": "2025-12-14 15:33:12",
  "count": 2,
  "details": [
    {
      "name": "测试用户1",
      "cost": 0,
      "oldRoi": 15.5,
      "newRoi": 11.5,
      "status": "success",
      "message": "连续2次0消耗"
    },
    {
      "name": "测试用户2",
      "cost": 2.5,
      "oldRoi": 10.0,
      "newRoi": 18.0,
      "status": "success",
      "message": null
    }
  ]
}
```

# 总结

自动ROI调控系统采用了分层设计，具有清晰的逻辑流程和完善的边界处理。系统通过连续0消耗的特殊处理和基于消耗区间的常规调控，实现了高效的ROI自动调整。同时，系统还包含了完善的日志记录和异常处理机制，确保了系统的可靠性和可维护性。

该系统可以根据业务需求进行扩展，支持动态配置、自定义策略和机器学习优化等高级功能。